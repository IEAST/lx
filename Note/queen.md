# 4皇后解析
---
## 问题分析
1. 问题重点: 
   - 皇后不能再同一行,同一列,同一斜线
   - 一共有四个皇后
   - 棋盘 4*4
2. 实现方法:
    1. 先确定第一个queen的位置.(它可以在任意位置))
   ```c
   int Q1[m][n]; // 1<=m<=4 1<=n<=4
   ```
    2. 确定第二个queen的位置.(它无法与第一个的queen在同一列,同一斜线)
   ```c
   int Q2[i][k];// i!=m ;k!=n;且不能再同一斜线
   ``` 
   3. 确定第三个的queen的位置.(它无法与第一个和第二个的queen在同一列,同一斜线)
    ```c
    int Q3[r][l]; //r!=m!=i l!=k!=n,且他们不能再同一条斜线上
    ```
    1. 确定第四个queen的位置.(条件与前面一致)
   ```c
   int Q4[x][y]; //x!=m!=i!=r y!=n!=k!=l; 并且不能再同一条斜线上
   ```
3. 为了方便比较是否在同一行,同一列,同一斜线上,我们可以写出如下方法
```c
int isCorrect(int i, int j, int (*Q)[4]) //i,j 分别是行和列,Q是棋盘
{
    int s, t;
    for(s=i,t=1; t<=4; t++)
        if(Q[s][t]==1 && t!=j)
            return 0;//判断同一行上是否有皇后
    for(t=j,s=1; s<=4; s++)
        if(Q[s][t]==1 && s!=i)
            return 0;//判断同一列上是否有皇后
    for(s=i-1,t=j-1; s>=1&&t>=1; s--,t--)
        if(Q[s][t]==1)
            return 0;//判断左上方是否有皇后
    for(s=i+1,t=j+1; s<=4&&t<=4;s++,t++)
        if(Q[s][t]==1)
            return 0;//判断右下方是否有皇后
    for(s=i-1,t=j+1; s>=1&&t<=4; s--,t++)
        if(Q[s][t]==1)
            return 0;//判断右上方是否有皇后
    for(s=i+1,t=j-1; s<=4&&t>=1; s++,t--)
        if(Q[s][t]==1)
            return 0;//判断左下方是否有皇后

    return 1;//否则返回
}
```

## 回溯法:
### 大意分析
- 先放第一个皇后,它可以在任意位置.
- 放第二个皇后,如果通过上面的函数判断它是否符合位置,如果不符合,那么将寻找它的下一个位置
- 放第三个皇后,如果找不到合适位置,那么我们将放回第二个皇后,判断他是否还有其他可放置的位置,如果有,改变第二个皇后的位置,在判断第三个皇后是否为位置放置
- 第四个皇后同理

### [代码](../C/queen.c)